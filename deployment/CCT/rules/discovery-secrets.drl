package secrets

import java.util.List;
import java.util.Map;
import java.util.HashMap;
import java.util.ArrayList;

import com.stratio.tais.cns.Senses
import com.stratio.tais.cns.exceptions.MesosSecretException
import com.stratio.tais.persistence.model.ConceptState
import com.stratio.tais.persistence.model.ErrorConcept
import com.stratio.tais.persistence.model.GlobalParameter
import com.stratio.tais.persistence.model.ServiceConfigurationParameter
import com.stratio.tais.persistence.model.ServiceDeployment
import com.stratio.tais.persistence.model.ServiceDeploymentParameter
import com.stratio.tais.persistence.model.secret.CertificateSecretRequest
import com.stratio.tais.persistence.model.secret.PasswordSecretRequest
import com.stratio.tais.persistence.model.service.ServiceConfiguration
import com.stratio.tais.persistence.model.service.networking.NetworkingExposeServiceModel
import com.stratio.tais.senses.service.RandomStringGenerator
import com.stratio.tais.senses.service.VaultSense
import com.stratio.tais.senses.utils.VaultUtils
import com.stratio.tais.service.util.InterpolationUtils
import com.stratio.tais.service.util.DeploymentUtils
import com.stratio.tais.service.util.UniverseUtils


rule "Deployment - Secrets Discovery - MarathonLB"
salience 1000
when
   $deploymentService: ServiceDeployment(
      deploymentState == ServiceDeployment.STATE_CREATING_DEPLOYMENT,
      $serviceDeploymentGlobalId: uuid,
      serviceConfiguration != null,
      serviceConfiguration.serviceName != null,
      serviceConfiguration.serviceName == "discovery",
      secretsCreated == false)
   $serviceConfiguration: ServiceConfiguration(
      $serviceConfigurationGlobalId: uuid, state  == ConceptState.LEARNED,
      uuid == $deploymentService.serviceConfigurationGlobalId)
   $serviceConfParameter: ServiceConfigurationParameter(
      parent == $serviceConfigurationGlobalId,
      internalName == UniverseUtils.PARAM_SERVICE_ID, $name: name  )
   $serviceDeploymentParameter: ServiceDeploymentParameter(
      parent == $serviceDeploymentGlobalId, name ==$name )
   $haproxyhost: ServiceDeploymentParameter(
           parent == $serviceDeploymentGlobalId, name =="haproxyhost" )
then

    String discoveryWithTenantName = VaultUtils.sanitizeSecretIdentity($serviceDeploymentParameter.getValue());
	  System.out.println("Create SECRETS Discovery with identity: " + discoveryWithTenantName);

	  System.out.println("Create discovery certificate...");

	  System.out.println("Service Identity with Tenant name: " + discoveryWithTenantName);

    String path_marathon = VaultUtils.sanitizeSecretIdentityWithPath($serviceDeploymentParameter.getValue());
    System.out.println("Marathon path:" + path_marathon);
    String mesosDns = path_marathon + ".marathon.mesos";
    System.out.println("mesosDns:" + mesosDns);

    String vhost = $haproxyhost.getValue();
    System.out.println("vhost:" + vhost);

    String SANs = mesosDns + "," + vhost;
    System.out.println("SANs:" + SANs);


    String certificatesPath = "userland/certificates/".concat(discoveryWithTenantName);
    System.out.println("Certificate path:" + certificatesPath);


    CertificateSecretRequest cert = new CertificateSecretRequest(certificatesPath,
    discoveryWithTenantName, discoveryWithTenantName, SANs);
    cert.setParent($serviceDeploymentGlobalId);
    insert(cert);

    PasswordSecretRequest keystore = new PasswordSecretRequest("userland/passwords/".concat(discoveryWithTenantName), "keystore", null, RandomStringGenerator.randomString(10));
    keystore.setParent($serviceDeploymentGlobalId);
    insert(keystore);

    PasswordSecretRequest jwtsecret = new PasswordSecretRequest("userland/passwords/".concat(discoveryWithTenantName), "jwtsecret", null, RandomStringGenerator.randomString(10));
    jwtsecret.setParent($serviceDeploymentGlobalId);
    insert(jwtsecret);

    // Gosec sso related secrets (client secret and client id, discovery gets the client id from vault)
    String gosecSsoClientSecret = RandomStringGenerator.randomString(15);
    String gosecSsoClientId = discoveryWithTenantName.concat("-oauth-id");
    PasswordSecretRequest gosecsso = new PasswordSecretRequest(
        "userland/passwords/".concat(discoveryWithTenantName), "oauth", gosecSsoClientId, gosecSsoClientSecret
    );
    gosecsso.setParent($serviceDeploymentGlobalId);
    insert(gosecsso);

    $deploymentService.setSecretsCreated(true);
    update($deploymentService);

end

rule "Set HAPROXY_VAULT_CERT label to tell marathon-lb where to find the service certificates in Discovery"
when
  $deploymentService: ServiceDeployment(
	  $serviceDeploymentGlobalId: uuid,
		serviceConfiguration != null,
		serviceConfiguration.serviceName != null,
		serviceConfiguration.serviceName == "discovery",
        serviceConfiguration.container != null,
        serviceConfiguration.container.runners != null,
        containersCreated == true,
        deployment != null)
	$identity: ServiceDeploymentParameter(
    parent == $serviceDeploymentGlobalId, name == "discoveryInstanceName")
  eval($deploymentService.getDeployment().getLabels() != null)
  eval(!$deploymentService.getDeployment().getLabels().containsKey("HAPROXY_VAULT_CERT"))
then
    System.out.println("Setting HAPROXY_VAULT_CERT in discovery service");

    // interpolate identity (composed form dcosServiceName-tenant)
    List<ErrorConcept> interpolationErrors = new ArrayList();
    HashMap<String,Object> environment = InterpolationUtils.extractParametersForInterpolation($deploymentService);
    String identity = (String)InterpolationUtils.interpolateValue($identity.getValue(), environment, interpolationErrors);

    Map<String, String> labels = $deploymentService.getDeployment().getLabels();
    labels.put("HAPROXY_VAULT_CERT", "/userland/certificates/" + identity + "/" + identity);
end

rule "Deployment - Secrets Discovery - Governance"
salience 1000
when
   $deploymentService: ServiceDeployment(
      deploymentState == ServiceDeployment.STATE_CREATING_DEPLOYMENT,
      $serviceDeploymentGlobalId: uuid,
      serviceConfiguration != null,
      serviceConfiguration.serviceName != null,
      serviceConfiguration.serviceName == "discovery",
      serviceConfiguration.model == "governance",
      secretsCreated == false)
   $serviceConfiguration: ServiceConfiguration(
      $serviceConfigurationGlobalId: uuid, state  == ConceptState.LEARNED,
      uuid == $deploymentService.serviceConfigurationGlobalId)
   $serviceConfParameter: ServiceConfigurationParameter(
      parent == $serviceConfigurationGlobalId,
      internalName == UniverseUtils.PARAM_SERVICE_ID, $name: name)
   $serviceDeploymentParameter: ServiceDeploymentParameter(
      parent == $serviceDeploymentGlobalId, name ==$name )
then

    String discoveryWithTenantName = VaultUtils.sanitizeSecretIdentity($serviceDeploymentParameter.getValue());
	  System.out.println("Create SECRETS Discovery with identity: " + discoveryWithTenantName);

	  System.out.println("Create discovery certificate...");

	  System.out.println("Service Identity with Tenant name: " + discoveryWithTenantName);

    VaultSense vault = Senses.access(VaultSense.class);
    String path_marathon = VaultUtils.sanitizeSecretIdentityWithPath($serviceDeploymentParameter.getValue());
    System.out.println("Marathon path:" + path_marathon);
    String SANs = path_marathon + ".marathon.mesos";
    System.out.println("SANs:" + SANs);

    String certificatesPath = "userland/certificates/".concat(discoveryWithTenantName);
    System.out.println("Certificate path:" + certificatesPath);

    CertificateSecretRequest cert = new CertificateSecretRequest(certificatesPath,
    discoveryWithTenantName, discoveryWithTenantName, SANs);
    cert.setParent($serviceDeploymentGlobalId);
    insert(cert);

    PasswordSecretRequest keystore = new PasswordSecretRequest("userland/passwords/".concat(discoveryWithTenantName), "keystore", null, RandomStringGenerator.randomString(10));
    keystore.setParent($serviceDeploymentGlobalId);
    insert(keystore);

    try {
        String oauthKeyPath = "/dcs/passwords/oauth/jwtsecret";
        String ssoUser = String.valueOf(vault.fetchSecret(oauthKeyPath).get().get("user"));
        String ssoPass = String.valueOf(vault.fetchSecret(oauthKeyPath).get().get("pass"));
        PasswordSecretRequest jwtInstance = new PasswordSecretRequest("userland/passwords/".concat(discoveryWithTenantName), "jwtsecret", ssoUser, ssoPass);
        jwtInstance.setParent($serviceDeploymentGlobalId);
        insert(jwtInstance);
    } catch (Exception e) {
             insert(new ErrorConcept(ErrorConcept.SECRETS_ERROR, e.getMessage(), null, $serviceDeploymentGlobalId));
    }

    $deploymentService.setSecretsCreated(true);
    update($deploymentService);

end
